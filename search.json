[{"title":"Java复习笔记9","url":"/2018/08/16/Java复习笔记9/","content":"Dog dog = new Dog();\ndog.swim();\n上面的代码，对象的创建、属性的赋值和对象方法的调用，都是在编译期决定的\n反射:reflection\n\t程序的一种内省机制\n\t程序可以在运行期动态的创建对象、获取对象类型、调用对象行为\n内省机制在Java和.net语言中有，在早期的c,c++,delphi,vb这些语言都没有内省机制。\n\n//可变参数\npublic void main(String... args){}\n//反编译后是一个参数数组\npublic transient void main(String[] args){}\n\nClass:\n\t类的实例代表一个运行 类 java应用程序的类和接口。\n\tClass<Dog> aa = Dog.class;  //获取数据类型\n\n\tDog dog = new Dog();\n\tClass<Dog> bb = dog.getClass();//在运行期，动态获取对象的数据类型\n\n\tClass.forName(\"com.nepu.Dog\"); //返回与给定的字符串名称的类或接口相关的 类对象。 \n\t\t1.检查数据类型是否存在\n\t\t2.通过静态代码块给静态变量初始化 -----静态变量存储与JVM的方法区\n\t\t3.ClassLoader，把数据类型加载到JVM的方法区\n\t\t4.返回Class对象\n\n\tClass.forName(\"oracle.jdbc.driver.OracleDriver\");\n\tConnection conn = DriverManager.getConnection(\"xxx\",\"ccc\",\"sss\");\n\t\t作用：检查驱动是否存在\n\t\t \t 通过静态代码块，给静态变量初始化\n\n\tString path = Dog.class.getResourse(\"\\\").toURI().getPath();\n\t\t动态获取程序允许路径\n\n\tField[] getDeclaredFields() ；返回 Field物体反射所有字段的类或接口的 类对象表示声明数组。 \n\t\t一个Field提供有关信息和动态访问，一个类或接口的一个单一的领域。反射场可以是一个类（静态）字段或一个实例字段。\n\t方法[] getDeclaredMethods() ;\n\t\t返回一个数组包含 方法物体反射所有声明的方法的类或接口的类对象，代表包括公众、保护，默认（包）的访问，和私有方法，但不包括继承的方法。   \n\n\t方法 getMethod(String name, 类<?>... parameterTypes) ;\n\t\t返回一个 方法对象反映的类或接口的 类对象表示的指定公共成员方法。  \n\tT newInstance() ;创建这个 类对象表示的类的一个新实例。  \n\tConstructor<T> getDeclaredConstructor(类<?>... parameterTypes) ；返回一个 \t   \n\t\t\t\t\tConstructor对象反映指定的构造函数的类或接口的 类对象表示。 \n\t动态创建对象：\n\t\tClass aa = Dog.class;\n\t\tObject dog = aa.newInstance();  //无参\n\t\tObject dog = aa.getDeclaredConstructor(String.class).newInstance(\"旺财\"); //有参\n\t\tMethod mm = aa.getDeclaredMethod(\"playDisc\",String.class);\n\t\tmm.invoke(dog,\"椭圆\");    //动态调用对象的行为\n\nMethod:\n\t方法：\n\t\tObject invoke(Object obj, Object... args) ;调用底层的方法，这 方法对象表示，对指定对象的指定参数。  \n\n设计模式：\n\t单例：数据库链接信息读取（在程序运行期间动态判断对象的hashcode()值是否一样）\n\t工厂模式：\n\t\t抽线工厂：\n\t\t工厂方法：\n\t\t简单工厂：\n\t组合模式(component)：Swing控件库设计结构\n\t观察者模式(Observer,subscibe/publish)（发布订阅模式）：Swing的事件机制\n\t代理模式（proxy）：\n\t\t静态代理：\n\t\t动态代理:\n\t\thibernate懒加载\n"},{"title":"Java复习笔记8","url":"/2018/08/16/Java复习笔记8/","content":"进程: process\n\t每一个进程，在操作系统中都有独立的内存空间，进程间互不干扰。\n线程：thread\n\t线程可以看成一条进程内存空间的访问路径。\n\t当前的操作系统都是多任务，并发的操作系统，允许多任务同时执行，\n\t可是CPU数量有限，这是就需要采用CPU分片的技术模拟实现多线程并发操作。\n\tCPU任务分片时，需要不停的切换上下文，这比较耗效率。（线程池、NIO）\n\t\tredis,node.js     -----服务器进行单线程\n\n\t注意：run()方法，无参，无返回值，无异常抛出，\n\t\t  因为run()方法不是给编程人员调用的，是给JVM来调用的。\n\t线程不能被强制结束\n\t当run()方法结束后，自动结束。\n\t线程中yield()与sleep()方法：\n\t\tyiled():使当前线程对CPU的占用率产生暂停，让别的线程有机会抢到CPU的使用权。\n\t\tsleep()：使当前线程的状态进入到阻塞状态，但为放弃CPU使用权\n\t\tjoin():在一个线程进入run()方法中，加入另一个线程，把当前线程置为阻塞状态，\n\t\t\t\t只有join的run()方法执行完之后，才会执行当前对象的run()方法。\n锁：\n\tsynchronized:\n\t\t1.synchronized锁方法：\n\t\t\t当多个线程调用同一个对象的方法时，只能有一个线程进入这个方法体内，其他的线程在外面排队。\n\t\t2.synchronized锁代码块：\n\n\t\t3.锁对象：\n\t\t\tDog d = new Dog();\n\t\t\tsynchronized(d){\n\t\t\t\t//给dog对象加锁后，其他线程都无法给dog再次加锁。 ---排他锁\n\t\t\t\t//意味着：在当前代码块中，可以多次调用dog中的方法，而不受其他线程影响。\n\t\t\t}\n\tLock:（接口）\n\t\t读写分离，写锁时排他的，读锁是共享的。\n\t\t方法：\n\t\t\tvoid lock() ；获取锁。  \n\t\t\tvoid unlock() ；释放锁。 \n\t\tReadWriteLock（接口）：\n\t\t\t方法：\n\t\t\t\treadLock Lock readLock()；返回用于读取的锁 \n\t\t\t\twriteLock Lock writeLock()；返回用于写入的锁。\n用native关键字，调用其他语言平台的类库\n"},{"title":"Java复习笔记7","url":"/2018/08/16/Java复习笔记7/","content":"2018.8.3\nURI:统一资源标识符\nFile(String pathname) \n\t通过将给定的路径名的字符串转换成一个抽象路径名创建一个新的 File实例。 \n\t注意：这个File可能是文件，也可能是文件夹\n\t方法：\n\t\tboolean exists() ;检查文件或目录是否存在这种抽象路径名记。  \n\t\tboolean isDirectory() ；测试文件是否通过这种抽象路径名表示是一个目录。\n\t\tboolean isFile() ；测试文件是否通过这种抽象路径名表示的是一种正常的文件。    \n\t\tFile[] listFiles() ；返回表示抽象路径名的目录中的文件的路径名表示抽象的数组。  \n\t\tboolean mkdir() ；创建该目录下的抽象路径名命名。 \n\t\tString getPath() ；转换这个抽象路径名为路径名的字符串。 \n\t\t----------------------------------------------------------------------\n\t\tboolean createNewFile() ；自动创建一个新的空文件命名的抽象路径名的当且仅当该文件不存在。  \n\t\tboolean delete() ；删除文件或目录的路径名表示的抽象。  \n\t\tString getName() ；返回的名称的文件或目录的路径名表示的抽象。 \n递归\n\t递归特点：\n\t\t1.自身调自身\n\t\t2.一定有退出地址\n\t递归场景：（都是树状结构）\n\t\t统计目录和文件\n\t\t统计部门下的人员\n\t\t统计XML文件中的信息\nCorba是早期进行分布式开发的重要框架\n\t它是跨平台的，可以进行异构系统之间的接口调用\n\tLDL(Interface Define Language)接口定义语言：用于异构的数据交互\n\tIIOP协议\n\n *               读     ——BufferedReader\n *            |——Reader|\n *   |——字符流|         ——InputSteamReader_____________FileReader\n *   |       |     写   ——BufferedWriter\n *   |       |—— Writer|\n *   |                  —— OutputSteamWriter___________FileWriter\n * 流|\n *   |             读        |——FileInputStream\n *   |        |——InputStream|\n *   |——字节流|             |——FilterInputStream__________BufferedInputStream\n *           |    写        |——FileOutputStream\n *           |——OutputStream|\n *                          |—— FilterOutputStream_________BufferedOutputStream\njava.io\n\tInputStream(抽象类)读\n\t\t方法：\n\t\t\tint read(byte[] b) ；读取一定数量的字节从输入流并存入缓冲区阵列 b。  \n\t\t\t\t实际读取的字节数作为整数返回，(读取文件流的最后一次，缓冲区不满的情况，)\n\t\t\t\tbyte[] b = new byte[1024];习惯上我们建立1k的buffer\n\t\t\tvoid close() ；关闭此输入流并释放与流关联的任何系统资源。  \n\t\t实现类：\n\t\t\tFileInputStream：\n\t OutputStream写\n\t \t方法：\n\t \t\tvoid write(byte[] b) ；写 b.length字节从指定的字节数组的输出流。 \n\t \t\tvoid write(byte[] b, int off, int len) ；写 len字节指定字节数组中的偏移 off开始到输出流。  \n\t \t\tvoid flush() ；刷新输出流，使缓存数据被写出来。 \n\t \t\tvoid close() ；关闭此输出流并释放与此流关联的任何系统资源。 \n\t \t实现类：\n\t \t\tFileOutputStream:\n\tReader读\n\t\t方法：\n\t\t\tint read() ；读取单个字符。  \n\t\t\tabstract void close() ；关闭流并释放与它相关联的任何系统资源。  \n\t\t实现类：\n\t\t\tBufferedReader:\n\t\t\t\t方法：\n\t\t\t\t\tString readLine() ；读一行文本。 \n\t\t\t\t\t\t读一行文本。一条线是由一个换行的任何一个终止（'\\n'），回车（“R”），或一个回车紧接着换行\n\tWriter写\n\t\t方法：\n\t\t\tvoid write(String str) ；写一个字符串。\n\t\t实现类：\n\t\t\tBufferedWriter：\n\t\t\t  \t\t\t\t\t\nBIO：blocking IO(一个线程读的时候，别的线程排队等待)\nNIO:NonBlocking IO(采用多路复用的机制，用一个线程去满足多个线程的读取)\n\n序列化(Serializable)\n\t把一个实体对象写入文件或进行网络传输\n\tjava.io \n\t\tInterface Serializable\n\t\t\t1.对于可序列化的子类，必须可以访问无参构造\n\t\t\t2.要序列化的类尽量要简单，如没有aggreation的其他对象\n\n分布式交互：\n\tRPC模式：（Remote Proecudre call）远程过程调用\n\t\t像调用本地程序一样的去调用远程程序\n\t\t核心：客户端需要有和服务器端一样的对接口的描述，还有对数据对象的描述\n\t\tstub ---- skeleton\n\tHTTP模式 ----JSON模式"},{"title":"Java复习笔记6","url":"/2018/08/16/Java复习笔记6/","content":"2018.8.1\njava.util\nInterface Collection<E>\n\t一组Object的集合\n\t这个接口和子接口、子类都是集合\n\tCollection集合可能是有序的，也可能是无序的。所以不能使用索引下标进行遍历。\n\n\tboolean add(E e)添加\n\tboolean remove(Objece o)移除\n\tint size() 大小\njava.lang\nInterface Iterable<T> 使用迭代器，对集合进行统一遍历\n\n静态数组空间大小是一定的，最大的缺陷是数据是动态的，很难提前预估数组的大小。\n静态数组的遍历方式是按照索引下标进行循环。\n\nCollection 接口\n\tList接口: 有序集合,列表可以添加重复元素。\n\t\tvoid add(int index,E element)添加\n\t\tE get(int index)按下标找值\n\t\tE remove(int index)按索引移除\n\t\tE set(int index)替换\n\t\t\t实现类：ArrayList:数据结构是静态数组(非线程安全的)\n\t\t\t\t\t\t构造具有指定初始容量的空列表\n\t\t\t\t\t\t初始化大小为10\n\t\t\t\t\t\t//初始化大小非常重要，最好只产生一次重新分配内存的机会\n\t\t\t\t\t\t//增加到原来的1.5倍\n\t\t\t\t\t\t//内存重新分配后，需要把原来的内存拷贝到新的静态数组中，非常消耗性能\n\t\t\t\t\t\t//使用场景：读取数据库中的数据，进行列表显示\n\t\t\t\t   LinkedList：链表\n\t\t\t\t   \t\t//采用静态内部类来定义一个节点\n\t\t\t\t   \t\t//优势，插入和删除的速度块\n\t\t\t\t   \t\t//使用链表Node来实现了一个先进先出的队列，又是一个有序集合\n\t\t\t\t   \t\t重要方法：\n\t\t\t\t   \t\t\taddFirst(E e);\n\t\t\t\t   \t\t\taddLast(E e);\n\t\t\t\t   \t\t\tE element(); 检索但不删除表头\n\t\t\t\t   \t\t\tE peek(); 检索但不删除表头\n\t\t\t\t   Stack:栈LIFO\n\t\t\t\t   \t\t/**\n \t\t\t\t\t\t* Stack继承Vector,栈是后进先出的。\n \t\t\t\t\t\t* 方法：\n \t\t\t\t\t\t* 1.empty();测试堆栈是否为空\n \t\t\t\t\t\t* 2.peek();查看栈顶部的对象，但不从堆栈中移除它\n \t\t\t\t\t\t*  \t\t与LinkedList的peek()方法不同，他是从栈顶即数组尾部查看数据。\n \t\t\t\t\t\t* 3.pop();移除堆栈顶部的对象，并作为此函数的返回值返回\n \t\t\t\t\t\t* 4.push(E item);把项压入堆栈顶部\n \t\t\t\t\t\t* 5.search(Object o);返回对象在堆栈中的位置，以1为基数\n\t\t\t\t\t\t*/\n\t\t\t\t   Vector:线程安全\n\t\t\t\t   \t\t//增加到原来的两倍。\n\t\t\t\t   \t\tsynchronized关键字修饰方法\n\t\t\t\t   \t\t\t多个线程对一个对象的一个方法进行操作，则只能有一个线程执行这个方法，其他线程等待（线程独享）\n\tSet接口:不包含重复元素。\n\t\t实现类：\n\t\t\tHashSet:\n\t\t\t\t底层数据结构是HashMap，\n\t\t\t\tHashMap<k,v>,实际是把算有value置为空，而HashSet<E>存储的就是\n\t\t\t\t\t常用方法：\n\t\t\t\t\t\t1.HashSet() 构建了一个新的，空的设置；支持HashMap实例具有默认初始容量（16）和负载因子（0.75）。\n\t\t\t\t\t\t2.boolean add(E e) 如果没有已存在，则将指定的元素添加到该集合中。 \n\t\t\t\t\t\t3.boolean contains(Object o)  如果这套 true返回包含指定的元素。 \n\t\t\t\t\t\t4.boolean isEmpty()  返回 true如果这个集合不包含元素。 \n\t\t\t\t\t\t5.Iterator<E> iterator()  返回此集合中元素的迭代器。 \n\t\t\t\t\t\t6.boolean remove(Object o)  如果当前存在，则从该集合中移除指定的元素。 \n\t\t\t\t\t\t7.int size()  返回该集合中元素个数（其基数）。 \n\t\t\tTreeSet:\n\t\t\t\t基于 TreeMap NavigableSet实施。用他们的 natural ordering元素是有序的，或由  Comparator在设定的创作时间，这取决于使用哪个构造函数。\n\t\t\t\t\t常用方法：\n\t\t\t\t\t\t1.boolean add(E e)  如果没有已存在，则将指定的元素添加到该集合中。 \n\t\t\t\t\t\t2.E ceiling(E e)  返回最小的元素在这组大于或等于给定的元素，或  null如果没有这样的元素。 \n\t\t\t\t\t\t3.Comparator<? super E> comparator()  返回用于命令set中元素的比较，或 null如果使用此设置元素的 natural ordering。 \n\t\t\t\t\t\t4.boolean contains(Object o)  如果这套 true返回包含指定的元素。 \n\t\t\t\t\t\t5.Iterator<E> descendingIterator()  在这个集合中的元素上返回一个迭代器。 \n\t\t\t\t\t\t6.NavigableSet<E> descendingSet()  返回此集合中包含的元素的反向顺序视图。 \n\t\t\t\t\t\t7.E first()  返回当前在该集合中的第一个（最低的）元素。 \n\t\t\t\t\t\t8.E floor(E e)  返回最大的元素在这组小于或等于给定的元素，或 null如果没有这样的元素。 \n\t\t\t\t\t\t9.SortedSet<E> headSet(E toElement)  返回从这个集合的元素是严格小于 toElement部分。\n\t\t\t\t\t\t10.NavigableSet<E> headSet(E toElement, boolean inclusive)  返回从这个集合的元素都小于（或等于部分，如果 inclusive是真的） toElement。\n\t\t\t\t\t\t11.E higher(E e)  返回最小的元素在这套严格大于给定的元素，或 null如果没有这样的元素。 \n\t\t\t\t\t\t12.Iterator<E> iterator()  在这个集合中的元素上返回一个迭代器。 \n如果没有已存在，则将指定的元素添加到该集合中。  \n\tQueue接口：具有先进先出的特点，不是有序集合\n\t\t实现类：LinkedList，既是有序集合又是队列\n\t\t\t\tLinkedBlockingQueue<E>\n\t\t重要方法：\n\t\t    boolean\toffer(); 插入\n\t\t    E poll();  移除并返回\n\t\t注意：Queue的父接口是Colloction，使用Queue的时候，最好使用offer()和poll()方法,不要使用Collection 的add()和remove()方法。\nMap接口：\n\t映射键到值的对象。一张Map不能包含重复的键，每个键可以映射到至多一个值。 \n\t常用方法：\n\t\tSet<Map.Entry<K,V>> entrySet()  返回一个 Set视图的映射包含在这个Map。\n\t\tV get(Object key) 返回指定的键映射的值，或 null如果这个Map不包含的键映射。 \n\t\tSet<K> keySet()  返回一个 Set的关键视图包含在这个Map。\n\t\tV put(K key, V value) 将指定的值与此映射中的指定键关联（可选操作）。\n\t\tV remove(Object key)  如果存在（可选操作），则从该Map中移除一个键的映射。 \n\t\tdefault V replace(K key, V value)  仅当它当前映射到某一值时，替换指定的键的条目。\n\t实现类：\n\n\n一切皆对象\n\tjava.lang\n\t\tClass Object\n\t\t\tObject clone()  深拷贝，浅拷贝\n\t\t\tboolean equals(Object obj) 比较对象的值，而不是地址\n\t\t\tvoid finalize() 垃圾回收，无需调用，应该由GC调用\n\t\t\t\ttry{\n\t\t\t\t}finally{\n\t\t\t\t   //在此处回收try中的非托管资源\n\t\t\t\t}\n\t\t\t\t托管资源：由GC处理\n\t\t\t\t非托管资源：由开发人员处理\n\t\t\t类<?> getClass 返回对象运行时类，  反射操作\n\t\t\tint hashCode() 返回对象的哈希值。\n\t\t\t\t只要在执行java应用程序的多次在同一个对象上，则返回同一个整数哈希值\n\t\t\t\t不同对象可能有相同的hashcode\n\t\t\tvoid notify()唤醒正在等待对象监视器的单个线程\n\t\t\tvoid notifyAll()唤醒正在等待对象监视器的所有线程\n\t\t\tvoid wait() 当前线程等待\n"},{"title":"Java复习笔记5","url":"/2018/08/16/Java复习笔记5/","content":"public interface ISwim{\n\tdouble PAI = 3.14;\n\tvoid swim();\n}\n//反编译结果如下\npublic interface ISwim{\n\tpublic static final double PAI = 3.14;\n\tpublic abstract swim();\n}\n编译器常量:上述常量。\n运行期常量：String。\n//接口中可以放变量\npublic interface ISwim{\n\tpublic static final double PAI = 3.14;\n\tpublic abstract swim();\n\tDog d = new Dog(\"wwa\");\n}\n三个第三方记录日志的框架：\n\tLog4j,sl4j,apache.commons.logging\n接口是能力的体现，接口是一种约束"},{"title":"Java复习笔记4","url":"/2018/08/16/Java复习笔记4/","content":"访问修饰符:\n\tpublic:对象和类，包内及包外\n\tprivate:类内部\n\tprotected:包内及包外子类（主要用作子类调用父类属性），包内对象可以调，包外对象不能调\n\t默认：类及包内（包内与public作用一致）\n\n父类的构造：\n\tDog d1 = new Dog(\"a\");\n\tnew Dog();会创建两块内存，先分配父类内存，然后分配子类内存。\n\t父类如果有参构造，则参数必须由子类的构造函数传入。\n\tPet p1 = new Dog(\"a\");\n\tnew Dog();一次分配了两块内存，p1中存的是父类内存的首地址。\n\tPet p1;表示dog只能指向父类的内存空间。\n父类的引用要访问子类对象的内存，需要进行指针的强制转换。\n父类与子类都用同名的属性：\n\t父类引用指向父类属性。\n\t子类引用指向子类属性。\n重写：\n\t父类和子类有一个同名、同参、同返回值的方法，则子类的方法的首地址会覆盖父类方法的首地址。\nabstract类\n\t抽象类中可以有抽象方法和非抽象方法\n\t抽象类不能被new\n\t抽象方法的主要目的就是要求子类重新自己的抽象方法。\n优先使用组合，然后才是继承。\noop:规则\n\tSRP:Single-Resposibility Principle单一职责原则\n\tOCP:Open-Closed Principle开放封闭原则\n\t\t对功能的扩展是open的\n\t\t对程序代码的修改是close的\n\tLSO:Liskvo-Substitution Principle里氏替换原则\n\tISP:Interface-Segregation Principle接口隔离原则\n\tDIP:Dependecy-Inversion Principle依赖倒置原则\n接口：\n\t接口中没有属性，只有行为\n\t接口中都是抽象方法\n接口与抽象类的对比：\n\t抽象类他是个Class，既有属性，又有行为\n\t既有抽象方法，又有非抽象方法\n\t一个类可以实现多个接口，但是只能有一个父类（类不能多重继承）————增加了灵活度\n匈牙利命名法：例如m_strName\n业务类，场景类。"},{"title":"Java复习笔记3","url":"/2018/08/16/Java复习笔记3/","content":"public class Dog{\n\tpublic final int aa;\n\tpublic static final int bb;\n}\n成员变量是final。则必须要在构造函数中初始化。\n增加了static修饰符后，static与对象无关，则aa调用模式为Dog.bb。\n这样就绕过了构造函数，则必须要初始化，不能在构造函数中初始化。\n\nfinal修饰了一个引用类型，他锁定的是引用地址，不是应用对象中的内容\n\t\tfinal Dog d2 = new Dog();\n\t\td2.name(\"啊\");\n\t\td2 = d1; //报错。\npublic static final double PI = \"3.14\";\n\t编译器常量\n总结：\n\tfinal的特点：允许赋值一次，然后就不能修改\n\tstatic的特点:和对象无关，允许通过类命直接调用\n变量：生命期与作用域\n\t局部变量：定义在函数体内的变量（基本类型、引用类型）\n\t\t\t 作用域：定义局部变量的{}范围内\n\t\t\t 生命期：\n\t\t\t \t基本类型，当超过}。会被GC回收\n\t\t\t \t引用类型，查看引用计数\n\t\t局部变量是线程独享的模式，每个线程都有自己的内存空间\n\t成员变量：\n\t\t\t作用域：类内所有方法\n\t\t\t生命期：\n\t\t\t\t基本类型：属性和所在对象的生命期一致\n\t\t\t\t引用类型：组合对象的生命期，可能是在对象外面创建的，和当前对象无关\n\t\t\t很对对象的生命期，是由容器管理的\n\t\t\t\t@Bean,Spring容器，javaEE容器(tomcat,weblogic)\n\tstatic变量：\n\t\t\t不能定义在方法内，只能作为成员变量存在\n\t\t\t作用域：Dog.dd,相当于全局变量，可以在类的外部被大量调用\n\t\t\t生命期：\n\t\t\t\t\tstatic变量，可以被修改，从第一次调用才分配内存，直到程序结束，这块内存才被释放。\n\t\t\tstatic变量存在JVM的方法区中\n静态方法不能调用所在class的属性，属性是属于对象的，静态的是属于类的。\nDog d2;  //stack中分配了一个4字节的空间，用于存放地址\nd2 = new Dog();//在heap中分配内存，并返回这块内存的首地址\n\n继承关系(is-a)、组合关系(has-a)\n\t举例：班级Class{\n\t    List<Student> list;\n\t}\n\t学生Student{\n\t\tTClass tclass;\n \t}\n设计模式：优先使用组合然后才是继承（上例）\n工厂模式：\n\t抽象工厂\n\t工厂方法\n\t简单工厂(不在23中设计模式中)\n单例模式：\n"},{"title":"Java复习笔记2","url":"/2018/08/16/Java复习笔记2/","content":"C++与Java平台对比：\n\t2000年左右，java逐渐把c++替掉了\n\n\tC++有指针   好处： 速度快\n\t\t\t\t缺陷： 内存溢出、内存泄漏\n\t\t\t\tnew    分配内存\n\t\t\t\tdelete 释放内存\n\t变量：全局变量（C语言）  定义C语言函数外面的变量\n\t\t  成员变量（C++）  定义在类的内部，方法的外部\n\t\t  \t\t在构造函数分配内存，在析构函数释放内存\n\t\t  局部变量 ： 定义在函数或方法内\n\t\t  \t\t在函数内分配内存，在函数内释放内存\n\n\tJava没有内存泄漏：GC 垃圾回收机制\n\tJVM中有堆，虚拟机栈，本地方法栈，程序计数器等，方法区（运行期常量池）--static变量，字符型常量String，Class类型加载。\njava7,将static移入heap中\njava8，将字符床常量移入heap中\n\tC/C++是编译程序\n\tJava是半编译程序——>最终解释执行的\n\t\t*.java编译成*.class，字节码（与CPU无关）\n\tjavascript是纯解释性语言（newscape网景公司）\nJDK是什么语言开发的？\n\tJava和C语言\nJDK  JRE  JVM 之间的关系？\n-\n-\n-\npackage就是namespace，解决变量的命名冲突\n命名规范：\n\t包名全部小写\n\t类命：首字母大写，一定是名词\n\t方法：首字母小写，一定是动词，例getUserName（驼峰命名法）\n\nEclipse快捷键\n\tAlt+?\n\tCTRL+SHIFT+O  自动导包\n值类型（基本类性） ：内存空间确定，会放在 stack 中\n引用类性： 会放在heap中\n\n编程思想：\n\t面向过程编程----ooa\n\t面向对象编程----oop(object orient program)\n\t\t继承、封装、多态\n\t面向服务编程----sop(service orient program)\n\t面向切面编程----aop(aspest orient program)\n\nentity  实体  从业务需求中的名词去抽取\n\t\t名词都是概念，不是实体就是属性\n\n类 Class ： 类就是类型信息，从特殊到一般的抽取过程，抽象 Dog\n具象：由一般到特殊,Dog d1 = new Dog();\n实体类：只有属性，没有行为\n业务类：业务逻辑，一般只有行为，没有属性\nclass Dog{}\n\t类前面没有修饰符，叫做默认关键字\n\t默认关键字在包内有效\nDebug调试模式：\n\tF6单步调试\n\tF8由当前位置，调到下一个断点，就运行到结束位置\n构造函数的特点：\n\t没有返回值\n\t名字与类命完全相同\n方法名，同名不同参，被称作overload\n\n变量的作用域\n\t成员变量：类内部的所有方法都可以调用\n\t局部变量：定义在函数体内，作用域在定义的{}内\n\nstatic关键字：\n\tstatic变量的特点：\n\t\t生命期：\n\t\t作用域\n\t常量的定义:public static final double PI = 3.14;\n\tstatic方法的特点\n\tstatic变量的序列化\n\t静态内部类的特点\n\tstatic变量在集群中的特点\n\tstatic变量与C的全局变量对比\n\tstatic变量与ServletContext变量、application对象对比\n常量：\n\t编译器常量：public static final double PI = 3.14;\n\t运行期常量：例如String,\nfinal的特点:\n\t可以有一次赋值机会，赋值之后就不允许改变了，\n\tfinal可以修饰常量，也可以修饰变量\n\t场景举例:数据库链接的信息放在配置文件中，在构造函数中读取，然后在存储在final变量中。\n\t程序运行期间，数据库链接信息不允许变动。\n"},{"title":"java复习笔记1","url":"/2018/08/16/java复习笔记1/","content":"\nwww.apache.org       //超级项目\nwww.oracle.com      //java规范\nmvnrepository.com  //下载资源\n一条主线：\n 本地事务（编程式事务）——>XA事务——>声明性事务——>分布式事务（MQ消息队列——KafKa）\n两个架构：\n分布式：RPC   非RPC\n \t\t公网  局域网\n \t\t同构  异构             //服务器和客服端是否为同一平台\n \t微软：com——>dcom——>com+——>activeX(java中叫applet)\n \tCorba\n \tRMI——>EJB\n \tWeb Service\n \tDubbo\n \tSpring Cloud\nNoSql:\n\tSQL:mysql,oracle,sqlserver\n\tNoSql:redis,Mongodb,Hbase\nJava开发XA事务的重要性？\n\nSpring Framework:\n  《Enterprise developse whitout EJB》\n   Ioc:控制反转 （DI依赖注入）\n   AOP:切面编程\n开发模式：\n   EJB模式（重量级模式，必须依赖于EJB容器）\n   JSP + JavaBean\n      JavaBeans\n\t\tJavaBean是一种java类\n\t\tJavaBean必须是具体的和公共的，并且具备无参构造器\n\t\tJavaBean通过提供符合一致性设计模式的公共方法将内部域暴露称为属性\n\t\tJavaBean提供两种方法来访问Bean的内部状态：\n\t\t 1.访问器(getters)用来读JavaBean状态– 以小写get前缀开始,后跟属性名，属性名的第一个字母必须大写，返回值必须匹配相应修改器的方法的参数；如果访问器返回boolean值，则使用is前缀开始，后跟属性名，属性名第一个字母必须大写。\n\t\t 2.修改器(setters)用来改变JavaBean状态 – 以小写set前缀开始，后跟属性名，属性名的第一个字母必须大写，修改器的返回值通常为void\n\n   Spring声明性事务的模式（轻量级模式，无需EJB的容器）\nJavaEE开发模型：组件+容器（管理组件生命期）\n\nJSR\n甲骨文（兼并SUN公司）\n\tsun做的时提供JavaEE的全套规范和部分实现。\n\tSpring是基于JSR规范下的一套解决方案。\n\tSpring的核心两大功能：\n\t\t1.Enterprise developse whitout EJB。\n\t\t2.不要使用发明轮子——不做任何具体问题的解决方案，只做方案整合。\n\n"}]